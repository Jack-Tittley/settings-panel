/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/apexcharts@3.45.2/src/charts/BarStacked.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CoreUtils from"../modules/CoreUtils";import Bar from"./Bar";import Graphics from"../modules/Graphics";import Utils from"../utils/Utils";class BarStacked extends Bar{draw(s,i){let e=this.w;this.graphics=new Graphics(this.ctx),this.bar=new Bar(this.ctx,this.xyRatios);const t=new CoreUtils(this.ctx,e);s=t.getLogSeries(s),this.yRatio=t.getLogYRatios(this.yRatio),this.barHelpers.initVariables(s),"100%"===e.config.chart.stackType&&(s=e.globals.seriesPercent.slice()),this.series=s,this.barHelpers.initializeStackedPrevVars(this);let r=this.graphics.group({class:"apexcharts-bar-series apexcharts-plot-series"}),a=0,o=0;for(let t=0,l=0;t<s.length;t++,l++){let h,p,g,n,x=-1;this.groupCtx=this,e.globals.seriesGroups.forEach(((s,i)=>{s.indexOf(e.config.series[t].name)>-1&&(x=i)})),-1!==x&&(this.groupCtx=this[e.globals.seriesGroups[x]]);let d=[],b=[],u=e.globals.comboCharts?i[t]:t;this.yRatio.length>1&&(this.yaxisIndex=u),this.isReversed=e.config.yaxis[this.yaxisIndex]&&e.config.yaxis[this.yaxisIndex].reversed;let c=this.graphics.group({class:"apexcharts-series",seriesName:Utils.escapeString(e.globals.seriesNames[u]),rel:t+1,"data:realIndex":u});this.ctx.series.addCollapsedClassToSeries(c,u);let v=this.graphics.group({class:"apexcharts-datalabels","data:realIndex":u}),C=this.graphics.group({class:"apexcharts-bar-goals-markers"}),y=0,m=0,f=this.initialPositions(a,o,h,p,g,n);o=f.y,y=f.barHeight,p=f.yDivision,n=f.zeroW,a=f.x,m=f.barWidth,h=f.xDivision,g=f.zeroH,e.globals.barHeight=y,e.globals.barWidth=m,this.barHelpers.initializeStackedXYVars(this),1===this.groupCtx.prevY.length&&this.groupCtx.prevY[0].every((s=>isNaN(s)))&&(this.groupCtx.prevY[0]=this.groupCtx.prevY[0].map((s=>g)),this.groupCtx.prevYF[0]=this.groupCtx.prevYF[0].map((s=>0)));for(let i=0;i<e.globals.dataPoints;i++){const r=this.barHelpers.getStrokeWidth(t,i,u),f={indexes:{i:t,j:i,realIndex:u,bc:l},strokeWidth:r,x:a,y:o,elSeries:c,groupIndex:x,seriesGroup:e.globals.seriesGroups[x]};let Y=null;this.isHorizontal?(Y=this.drawStackedBarPaths({...f,zeroW:n,barHeight:y,yDivision:p}),m=this.series[t][i]/this.invertedYRatio):(Y=this.drawStackedColumnPaths({...f,xDivision:h,barWidth:m,zeroH:g}),y=this.series[t][i]/this.yRatio[this.yaxisIndex]);const H=this.barHelpers.drawGoalLine({barXPosition:Y.barXPosition,barYPosition:Y.barYPosition,goalX:Y.goalX,goalY:Y.goalY,barHeight:y,barWidth:m});H&&C.add(H),o=Y.y,a=Y.x,d.push(a),b.push(o);let X=this.barHelpers.getPathFillColor(s,t,i,u);c=this.renderSeries({realIndex:u,pathFill:X,j:i,i:t,groupIndex:x,pathFrom:Y.pathFrom,pathTo:Y.pathTo,strokeWidth:r,elSeries:c,x:a,y:o,series:s,barHeight:y,barWidth:m,elDataLabelsWrap:v,elGoalsMarkers:C,type:"bar",visibleSeries:0})}e.globals.seriesXvalues[u]=d,e.globals.seriesYvalues[u]=b,this.groupCtx.prevY.push(this.groupCtx.yArrj),this.groupCtx.prevYF.push(this.groupCtx.yArrjF),this.groupCtx.prevYVal.push(this.groupCtx.yArrjVal),this.groupCtx.prevX.push(this.groupCtx.xArrj),this.groupCtx.prevXF.push(this.groupCtx.xArrjF),this.groupCtx.prevXVal.push(this.groupCtx.xArrjVal),r.add(c)}return r}initialPositions(s,i,e,t,r,a){let o,l,h=this.w;return this.isHorizontal?(o=t=h.globals.gridHeight/h.globals.dataPoints,o=o*parseInt(h.config.plotOptions.bar.barHeight,10)/100,-1===String(h.config.plotOptions.bar.barHeight).indexOf("%")&&(o=parseInt(h.config.plotOptions.bar.barHeight,10)),a=this.baseLineInvertedY+h.globals.padHorizontal+(this.isReversed?h.globals.gridWidth:0)-(this.isReversed?2*this.baseLineInvertedY:0),i=(t-o)/2):(l=e=h.globals.gridWidth/h.globals.dataPoints,l=h.globals.isXNumeric&&h.globals.dataPoints>1?(e=h.globals.minXDiff/this.xRatio)*parseInt(this.barOptions.columnWidth,10)/100:l*parseInt(h.config.plotOptions.bar.columnWidth,10)/100,-1===String(h.config.plotOptions.bar.columnWidth).indexOf("%")&&(l=parseInt(h.config.plotOptions.bar.columnWidth,10)),r=h.globals.gridHeight-this.baseLineY[this.yaxisIndex]-(this.isReversed?h.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[this.yaxisIndex]:0),s=h.globals.padHorizontal+(e-l)/2),{x:s,y:i,yDivision:t,xDivision:e,barHeight:h.globals.seriesGroups?.length?o/h.globals.seriesGroups.length:o,barWidth:h.globals.seriesGroups?.length?l/h.globals.seriesGroups.length:l,zeroH:r,zeroW:a}}drawStackedBarPaths({indexes:s,barHeight:i,strokeWidth:e,zeroW:t,x:r,y:a,groupIndex:o,seriesGroup:l,yDivision:h,elSeries:p}){let g,n=this.w,x=a+(-1!==o?o*i:0),d=s.i,b=s.j,u=0;for(let s=0;s<this.groupCtx.prevXF.length;s++)u+=this.groupCtx.prevXF[s][b];let c=d;if(l&&(c=l.indexOf(n.config.series[d].name)),c>0){let s=t;this.groupCtx.prevXVal[c-1][b]<0?s=this.series[d][b]>=0?this.groupCtx.prevX[c-1][b]+u-2*(this.isReversed?u:0):this.groupCtx.prevX[c-1][b]:this.groupCtx.prevXVal[c-1][b]>=0&&(s=this.series[d][b]>=0?this.groupCtx.prevX[c-1][b]:this.groupCtx.prevX[c-1][b]-u+2*(this.isReversed?u:0)),g=s}else g=t;r=null===this.series[d][b]?g:g+this.series[d][b]/this.invertedYRatio-2*(this.isReversed?this.series[d][b]/this.invertedYRatio:0);const v=this.barHelpers.getBarpaths({barYPosition:x,barHeight:i,x1:g,x2:r,strokeWidth:e,series:this.series,realIndex:s.realIndex,seriesGroup:l,i:d,j:b,w:n});return this.barHelpers.barBackground({j:b,i:d,y1:x,y2:i,elSeries:p}),a+=h,{pathTo:v.pathTo,pathFrom:v.pathFrom,goalX:this.barHelpers.getGoalValues("x",t,null,d,b),barYPosition:x,x:r,y:a}}drawStackedColumnPaths({indexes:s,x:i,y:e,xDivision:t,barWidth:r,zeroH:a,groupIndex:o,seriesGroup:l,elSeries:h}){let p=this.w,g=s.i,n=s.j,x=s.bc;if(p.globals.isXNumeric){let s=p.globals.seriesX[g][n];s||(s=0),i=(s-p.globals.minX)/this.xRatio-r/2,p.globals.seriesGroups.length&&(i=(s-p.globals.minX)/this.xRatio-r/2*p.globals.seriesGroups.length)}let d,b=i+(-1!==o?o*r:0),u=0;for(let s=0;s<this.groupCtx.prevYF.length;s++)u+=isNaN(this.groupCtx.prevYF[s][n])?0:this.groupCtx.prevYF[s][n];let c=g;if(l&&(c=l.indexOf(p.config.series[g].name)),c>0&&!p.globals.isXNumeric||c>0&&p.globals.isXNumeric&&p.globals.seriesX[g-1][n]===p.globals.seriesX[g][n]){let s,i;const e=Math.min(this.yRatio.length+1,g+1);if(void 0!==this.groupCtx.prevY[c-1]&&this.groupCtx.prevY[c-1].length)for(let s=1;s<e;s++)if(!isNaN(this.groupCtx.prevY[c-s]?.[n])){i=this.groupCtx.prevY[c-s][n];break}for(let t=1;t<e;t++){if(this.groupCtx.prevYVal[c-t]?.[n]<0){s=this.series[g][n]>=0?i-u+2*(this.isReversed?u:0):i;break}if(this.groupCtx.prevYVal[c-t]?.[n]>=0){s=this.series[g][n]>=0?i:i+u-2*(this.isReversed?u:0);break}}void 0===s&&(s=p.globals.gridHeight),d=this.groupCtx.prevYF[0]?.every((s=>0===s))&&this.groupCtx.prevYF.slice(1,c).every((s=>s.every((s=>isNaN(s)))))?a:s}else d=a;e=this.series[g][n]?d-this.series[g][n]/this.yRatio[this.yaxisIndex]+2*(this.isReversed?this.series[g][n]/this.yRatio[this.yaxisIndex]:0):d;const v=this.barHelpers.getColumnPaths({barXPosition:b,barWidth:r,y1:d,y2:e,yRatio:this.yRatio[this.yaxisIndex],strokeWidth:this.strokeWidth,series:this.series,seriesGroup:l,realIndex:s.realIndex,i:g,j:n,w:p});return this.barHelpers.barBackground({bc:x,j:n,i:g,x1:b,x2:r,elSeries:h}),i+=t,{pathTo:v.pathTo,pathFrom:v.pathFrom,goalY:this.barHelpers.getGoalValues("y",null,a,g,n),barXPosition:b,x:p.globals.isXNumeric?i-t:i,y:e}}}export default BarStacked;
//# sourceMappingURL=/sm/13985bdba6b7a631e867cc38cd888ddefce69d09b52817c936a9a85bdb59628c.map