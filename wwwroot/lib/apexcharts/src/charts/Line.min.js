/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/apexcharts@3.45.2/src/charts/Line.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CoreUtils from"../modules/CoreUtils";import Graphics from"../modules/Graphics";import Fill from"../modules/Fill";import DataLabels from"../modules/DataLabels";import Markers from"../modules/Markers";import Scatter from"./Scatter";import Utils from"../utils/Utils";import Helpers from"./common/line/Helpers";import{svgPath,spline}from"../libs/monotone-cubic";class Line{constructor(e,s,t){this.ctx=e,this.w=e.w,this.xyRatios=s,this.pointsChart=!("bubble"!==this.w.config.chart.type&&"scatter"!==this.w.config.chart.type)||t,this.scatter=new Scatter(this.ctx),this.noNegatives=this.w.globals.minX===Number.MAX_VALUE,this.lineHelpers=new Helpers(this),this.markers=new Markers(this.ctx),this.prevSeriesY=[],this.categoryAxisCorrection=0,this.yaxisIndex=0}draw(e,s,t,i){let a=this.w,r=new Graphics(this.ctx),l=a.globals.comboCharts?s:a.config.chart.type,o=r.group({class:`apexcharts-${l}-series apexcharts-plot-series`});const n=new CoreUtils(this.ctx,a);this.yRatio=this.xyRatios.yRatio,this.zRatio=this.xyRatios.zRatio,this.xRatio=this.xyRatios.xRatio,this.baseLineY=this.xyRatios.baseLineY,e=n.getLogSeries(e),this.yRatio=n.getLogYRatios(this.yRatio);let h=[];for(let s=0;s<e.length;s++){e=this.lineHelpers.sameValueSeriesFix(s,e);let r=a.globals.comboCharts?t[s]:s;this._initSerieVariables(e,s,r);let o=[],n=[],c=[],g=a.globals.padHorizontal+this.categoryAxisCorrection,p=1,d=[],m=[];this.ctx.series.addCollapsedClassToSeries(this.elSeries,r),a.globals.isXNumeric&&a.globals.seriesX.length>0&&(g=(a.globals.seriesX[r][0]-a.globals.minX)/this.xRatio),c.push(g);let u,x,b,f=g,P=f,v=this.zeroY,y=this.zeroY,A=0;v=this.lineHelpers.determineFirstPrevY({i:s,series:e,prevY:v,lineYPosition:A}).prevY,"monotonCubic"===a.config.stroke.curve&&null===e[s][0]?o.push(null):o.push(v),u=v,"rangeArea"===l&&(b=this.lineHelpers.determineFirstPrevY({i:s,series:i,prevY:y,lineYPosition:A}),y=b.prevY,x=y,n.push(y));const Y={type:l,series:e,realIndex:r,i:s,x:g,y:p,pX:f,pY:u,pathsFrom:this._calculatePathsFrom({type:l,series:e,i:s,realIndex:r,prevX:P,prevY:v,prevY2:y}),linePaths:d,areaPaths:m,seriesIndex:t,lineYPosition:A,xArrj:c,yArrj:o,y2Arrj:n,seriesRangeEnd:i};let k=this._iterateOverDataPoints({...Y,iterations:"rangeArea"===l?e[s].length-1:void 0,isRangeStart:!0});if("rangeArea"===l){let e=this._calculatePathsFrom({series:i,i:s,realIndex:r,prevX:P,prevY:y}),t=this._iterateOverDataPoints({...Y,series:i,pY:x,pathsFrom:e,iterations:i[s].length-1,isRangeStart:!1});k.linePaths[0]=t.linePath+k.linePath,k.pathFromLine=t.pathFromLine+k.pathFromLine}this._handlePaths({type:l,realIndex:r,i:s,paths:k}),this.elSeries.add(this.elPointsMain),this.elSeries.add(this.elDataLabelsWrap),h.push(this.elSeries)}if(void 0!==a.config.series[0]?.zIndex&&h.sort(((e,s)=>Number(e.node.getAttribute("zIndex"))-Number(s.node.getAttribute("zIndex")))),a.config.chart.stacked)for(let e=h.length;e>0;e--)o.add(h[e-1]);else for(let e=0;e<h.length;e++)o.add(h[e]);return o}_initSerieVariables(e,s,t){const i=this.w,a=new Graphics(this.ctx);this.xDivision=i.globals.gridWidth/(i.globals.dataPoints-("on"===i.config.xaxis.tickPlacement?1:0)),this.strokeWidth=Array.isArray(i.config.stroke.width)?i.config.stroke.width[t]:i.config.stroke.width,this.yRatio.length>1&&(this.yaxisIndex=t),this.isReversed=i.config.yaxis[this.yaxisIndex]&&i.config.yaxis[this.yaxisIndex].reversed,this.zeroY=i.globals.gridHeight-this.baseLineY[this.yaxisIndex]-(this.isReversed?i.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[this.yaxisIndex]:0),this.areaBottomY=this.zeroY,(this.zeroY>i.globals.gridHeight||"end"===i.config.plotOptions.area.fillTo)&&(this.areaBottomY=i.globals.gridHeight),this.categoryAxisCorrection=this.xDivision/2,this.elSeries=a.group({class:"apexcharts-series",zIndex:void 0!==i.config.series[t].zIndex?i.config.series[t].zIndex:t,seriesName:Utils.escapeString(i.globals.seriesNames[t])}),this.elPointsMain=a.group({class:"apexcharts-series-markers-wrap","data:realIndex":t}),this.elDataLabelsWrap=a.group({class:"apexcharts-datalabels","data:realIndex":t});let r=e[s].length===i.globals.dataPoints;this.elSeries.attr({"data:longestSeries":r,rel:s+1,"data:realIndex":t}),this.appendPathFrom=!0}_calculatePathsFrom({type:e,series:s,i:t,realIndex:i,prevX:a,prevY:r,prevY2:l}){const o=this.w,n=new Graphics(this.ctx);let h,c,g,p;if(null===s[t][0]){for(let e=0;e<s[t].length;e++)if(null!==s[t][e]){a=this.xDivision*e,r=this.zeroY-s[t][e]/this.yRatio[this.yaxisIndex],h=n.move(a,r),c=n.move(a,this.areaBottomY);break}}else h=n.move(a,r),"rangeArea"===e&&(h=n.move(a,l)+n.line(a,r)),c=n.move(a,this.areaBottomY)+n.line(a,r);if(g=n.move(-1,this.zeroY)+n.line(-1,this.zeroY),p=n.move(-1,this.zeroY)+n.line(-1,this.zeroY),o.globals.previousPaths.length>0){const e=this.lineHelpers.checkPreviousPaths({pathFromLine:g,pathFromArea:p,realIndex:i});g=e.pathFromLine,p=e.pathFromArea}return{prevX:a,prevY:r,linePath:h,areaPath:c,pathFromLine:g,pathFromArea:p}}_handlePaths({type:e,realIndex:s,i:t,paths:i}){const a=this.w,r=new Graphics(this.ctx),l=new Fill(this.ctx);this.prevSeriesY.push(i.yArrj),a.globals.seriesXvalues[s]=i.xArrj,a.globals.seriesYvalues[s]=i.yArrj;const o=a.config.forecastDataPoints;if(o.count>0&&"rangeArea"!==e){const e=a.globals.seriesXvalues[s][a.globals.seriesXvalues[s].length-o.count-1],t=r.drawRect(e,0,a.globals.gridWidth,a.globals.gridHeight,0);a.globals.dom.elForecastMask.appendChild(t.node);const i=r.drawRect(0,0,e,a.globals.gridHeight,0);a.globals.dom.elNonForecastMask.appendChild(i.node)}this.pointsChart||a.globals.delayedElements.push({el:this.elPointsMain.node,index:s});const n={i:t,realIndex:s,animationDelay:t,initialSpeed:a.config.chart.animations.speed,dataChangeSpeed:a.config.chart.animations.dynamicAnimation.speed,className:`apexcharts-${e}`};if("area"===e){let e=l.fillPath({seriesNumber:s});for(let s=0;s<i.areaPaths.length;s++){let t=r.renderPaths({...n,pathFrom:i.pathFromArea,pathTo:i.areaPaths[s],stroke:"none",strokeWidth:0,strokeLineCap:null,fill:e});this.elSeries.add(t)}}if(a.config.stroke.show&&!this.pointsChart){let h=null;if("line"===e)h=l.fillPath({seriesNumber:s,i:t});else if("solid"===a.config.stroke.fill.type)h=a.globals.stroke.colors[s];else{const e=a.config.fill;a.config.fill=a.config.stroke.fill,h=l.fillPath({seriesNumber:s,i:t}),a.config.fill=e}for(let t=0;t<i.linePaths.length;t++){let c=h;"rangeArea"===e&&(c=l.fillPath({seriesNumber:s}));const g={...n,pathFrom:i.pathFromLine,pathTo:i.linePaths[t],stroke:h,strokeWidth:this.strokeWidth,strokeLineCap:a.config.stroke.lineCap,fill:"rangeArea"===e?c:"none"};let p=r.renderPaths(g);if(this.elSeries.add(p),p.attr("fill-rule","evenodd"),o.count>0&&"rangeArea"!==e){let e=r.renderPaths(g);e.node.setAttribute("stroke-dasharray",o.dashArray),o.strokeWidth&&e.node.setAttribute("stroke-width",o.strokeWidth),this.elSeries.add(e),e.attr("clip-path",`url(#forecastMask${a.globals.cuid})`),p.attr("clip-path",`url(#nonForecastMask${a.globals.cuid})`)}}}}_iterateOverDataPoints({type:e,series:s,iterations:t,realIndex:i,i:a,x:r,y:l,pX:o,pY:n,pathsFrom:h,linePaths:c,areaPaths:g,seriesIndex:p,lineYPosition:d,xArrj:m,yArrj:u,y2Arrj:x,isRangeStart:b,seriesRangeEnd:f}){const P=this.w;let v=new Graphics(this.ctx),y=this.yRatio,{prevY:A,linePath:Y,areaPath:k,pathFromLine:w,pathFromArea:I}=h;const R=Utils.isNumber(P.globals.minYArr[i])?P.globals.minYArr[i]:P.globals.minY;t||(t=P.globals.dataPoints>1?P.globals.dataPoints-1:P.globals.dataPoints);const S=(e,s)=>s-e/y[this.yaxisIndex]+2*(this.isReversed?e/y[this.yaxisIndex]:0);let F=l,z=P.config.chart.stacked&&!P.globals.comboCharts||P.config.chart.stacked&&P.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===this.w.config.series[i]?.type);for(let h=0;h<t;h++){const y=void 0===s[a][h+1]||null===s[a][h+1];if(P.globals.isXNumeric){let e=P.globals.seriesX[i][h+1];void 0===P.globals.seriesX[i][h+1]&&(e=P.globals.seriesX[i][t-1]),r=(e-P.globals.minX)/this.xRatio}else r+=this.xDivision;if(z)if(a>0&&P.globals.collapsedSeries.length<P.config.series.length-1){const e=e=>{let s=e;for(let t=0;t<P.globals.series.length;t++)if(P.globals.collapsedSeriesIndices.indexOf(e)>-1){s--;break}return s>=0?s:0};d=this.prevSeriesY[e(a-1)][h+1]}else d=this.zeroY;else d=this.zeroY;y?l=S(R,d):(l=S(s[a][h+1],d),"rangeArea"===e&&(F=S(f[a][h+1],d))),m.push(r),y&&"smooth"===P.config.stroke.curve?u.push(null):u.push(l),x.push(F);let L=this.lineHelpers.calculatePoints({series:s,x:r,y:l,realIndex:i,i:a,j:h,prevY:A}),C=this._createPaths({type:e,series:s,i:a,realIndex:i,j:h,x:r,y:l,y2:F,xArrj:m,yArrj:u,y2Arrj:x,pX:o,pY:n,linePath:Y,areaPath:k,linePaths:c,areaPaths:g,seriesIndex:p,isRangeStart:b});g=C.areaPaths,c=C.linePaths,o=C.pX,n=C.pY,k=C.areaPath,Y=C.linePath,!this.appendPathFrom||"monotoneCubic"===P.config.stroke.curve&&"rangeArea"===e||(w+=v.line(r,this.zeroY),I+=v.line(r,this.zeroY)),this.handleNullDataPoints(s,L,a,h,i),this._handleMarkersAndLabels({type:e,pointsPos:L,i:a,j:h,realIndex:i,isRangeStart:b})}return{yArrj:u,xArrj:m,pathFromArea:I,areaPaths:g,pathFromLine:w,linePaths:c,linePath:Y,areaPath:k}}_handleMarkersAndLabels({type:e,pointsPos:s,isRangeStart:t,i:i,j:a,realIndex:r}){const l=this.w;let o=new DataLabels(this.ctx);if(this.pointsChart)this.scatter.draw(this.elSeries,a,{realIndex:r,pointsPos:s,zRatio:this.zRatio,elParent:this.elPointsMain});else{l.globals.series[i].length>1&&this.elPointsMain.node.classList.add("apexcharts-element-hidden");let e=this.markers.plotChartMarkers(s,r,a+1);null!==e&&this.elPointsMain.add(e)}let n=o.drawDataLabel({type:e,isRangeStart:t,pos:s,i:r,j:a+1});null!==n&&this.elDataLabelsWrap.add(n)}_createPaths({type:e,series:s,i:t,realIndex:i,j:a,x:r,y:l,xArrj:o,yArrj:n,y2:h,y2Arrj:c,pX:g,pY:p,linePath:d,areaPath:m,linePaths:u,areaPaths:x,seriesIndex:b,isRangeStart:f}){let P=this.w,v=new Graphics(this.ctx),y=P.config.stroke.curve;const A=this.areaBottomY;if(Array.isArray(P.config.stroke.curve)&&(y=Array.isArray(b)?P.config.stroke.curve[b[t]]:P.config.stroke.curve[t]),"rangeArea"===e&&(P.globals.hasNullValues||P.config.forecastDataPoints.count>0)&&"monotoneCubic"===y&&(y="straight"),"monotoneCubic"===y){const i="rangeArea"===e?o.length===P.globals.dataPoints:a===s[t].length-2,r=o.map(((e,s)=>[o[s],n[s]])).filter((e=>null!==e[1]));if(i&&r.length>1){const i=spline.points(r);if(d+=svgPath(i),null===s[t][0]?m=d:m+=svgPath(i),"rangeArea"===e&&f){d+=v.line(o[o.length-1],c[c.length-1]);const e=o.slice().reverse(),s=c.slice().reverse(),t=e.map(((t,i)=>[e[i],s[i]])),i=spline.points(t);m=d+=svgPath(i)}else m+=v.line(r[r.length-1][0],A)+v.line(r[0][0],A)+v.move(r[0][0],r[0][1])+"z";u.push(d),x.push(m)}}else if("smooth"===y){let i=.35*(r-g);P.globals.hasNullValues?(null!==s[t][a]&&(null!==s[t][a+1]?(d=v.move(g,p)+v.curve(g+i,p,r-i,l,r+1,l),m=v.move(g+1,p)+v.curve(g+i,p,r-i,l,r+1,l)+v.line(r,A)+v.line(g,A)+"z"):(d=v.move(g,p),m=v.move(g,p)+"z")),u.push(d),x.push(m)):(d+=v.curve(g+i,p,r-i,l,r,l),m+=v.curve(g+i,p,r-i,l,r,l)),g=r,p=l,a===s[t].length-2&&(m=m+v.curve(g,p,r,l,r,A)+v.move(r,l)+"z","rangeArea"===e&&f?d=d+v.curve(g,p,r,l,r,h)+v.move(r,h)+"z":P.globals.hasNullValues||(u.push(d),x.push(m)))}else{if(null===s[t][a+1]){d+=v.move(r,l);const e=P.globals.isXNumeric?(P.globals.seriesX[i][a]-P.globals.minX)/this.xRatio:r-this.xDivision;m=m+v.line(e,A)+v.move(r,l)+"z"}null===s[t][a]&&(d+=v.move(r,l),m+=v.move(r,A)),"stepline"===y?(d=d+v.line(r,null,"H")+v.line(null,l,"V"),m=m+v.line(r,null,"H")+v.line(null,l,"V")):"straight"===y&&(d+=v.line(r,l),m+=v.line(r,l)),a===s[t].length-2&&(m=m+v.line(r,A)+v.move(r,l)+"z","rangeArea"===e&&f?d=d+v.line(r,h)+v.move(r,h)+"z":(u.push(d),x.push(m)))}return{linePaths:u,areaPaths:x,pX:g,pY:p,linePath:d,areaPath:m}}handleNullDataPoints(e,s,t,i,a){const r=this.w;if(null===e[t][i]&&r.config.markers.showNullDataPoints||1===e[t].length){let e=this.markers.plotChartMarkers(s,a,i+1,this.strokeWidth-r.config.markers.strokeWidth/2,!0);null!==e&&this.elPointsMain.add(e)}}}export default Line;
//# sourceMappingURL=/sm/299ab6fdaa27baa3e99e7fdc583235d9276780e6206e26d42b6c0e243b193ebf.map