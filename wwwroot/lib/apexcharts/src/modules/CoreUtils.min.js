/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/apexcharts@3.45.2/src/modules/CoreUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
class CoreUtils{constructor(e){this.ctx=e,this.w=e.w}static checkComboSeries(e){let s=!1,t=0,a=0;return e.length&&void 0!==e[0].type&&e.forEach((e=>{"bar"!==e.type&&"column"!==e.type&&"candlestick"!==e.type&&"boxPlot"!==e.type||t++,void 0!==e.type&&a++})),a>0&&(s=!0),{comboBarCount:t,comboCharts:s}}getStackedSeriesTotals(e=[]){const s=this.w;let t=[];if(0===s.globals.series.length)return t;for(let a=0;a<s.globals.series[s.globals.maxValsInArrayIndex].length;a++){let i=0;for(let t=0;t<s.globals.series.length;t++)void 0!==s.globals.series[t][a]&&-1===e.indexOf(t)&&(i+=s.globals.series[t][a]);t.push(i)}return t}getSeriesTotalByIndex(e=null){return null===e?this.w.config.series.reduce(((e,s)=>e+s),0):this.w.globals.series[e].reduce(((e,s)=>e+s),0)}getStackedSeriesTotalsByGroups(){const e=this.w;let s=[];return e.globals.seriesGroups.forEach((t=>{let a=[];e.config.series.forEach(((e,s)=>{t.indexOf(e.name)>-1&&a.push(s)}));const i=e.globals.series.map(((e,s)=>-1===a.indexOf(s)?s:-1)).filter((e=>-1!==e));s.push(this.getStackedSeriesTotals(i))})),s}isSeriesNull(e=null){let s=[];return s=null===e?this.w.config.series.filter((e=>null!==e)):this.w.config.series[e].data.filter((e=>null!==e)),0===s.length}seriesHaveSameValues(e){return this.w.globals.series[e].every(((e,s,t)=>e===t[0]))}getCategoryLabels(e){const s=this.w;let t=e.slice();return s.config.xaxis.convertedCatToNumeric&&(t=e.map(((e,t)=>s.config.xaxis.labels.formatter(e-s.globals.minX+1)))),t}getLargestSeries(){const e=this.w;e.globals.maxValsInArrayIndex=e.globals.series.map((e=>e.length)).indexOf(Math.max.apply(Math,e.globals.series.map((e=>e.length))))}getLargestMarkerSize(){const e=this.w;let s=0;return e.globals.markers.size.forEach((e=>{s=Math.max(s,e)})),e.config.markers.discrete&&e.config.markers.discrete.length&&e.config.markers.discrete.forEach((e=>{s=Math.max(s,e.size)})),s>0&&(s+=e.config.markers.hover.sizeOffset+1),e.globals.markers.largestSize=s,s}getSeriesTotals(){const e=this.w;e.globals.seriesTotals=e.globals.series.map(((e,s)=>{let t=0;if(Array.isArray(e))for(let s=0;s<e.length;s++)t+=e[s];else t+=e;return t}))}getSeriesTotalsXRange(e,s){const t=this.w;return t.globals.series.map(((a,i)=>{let r=0;for(let l=0;l<a.length;l++)t.globals.seriesX[i][l]>e&&t.globals.seriesX[i][l]<s&&(r+=a[l]);return r}))}getPercentSeries(){const e=this.w;e.globals.seriesPercent=e.globals.series.map(((s,t)=>{let a=[];if(Array.isArray(s))for(let t=0;t<s.length;t++){let i=e.globals.stackedSeriesTotals[t],r=0;i&&(r=100*s[t]/i),a.push(r)}else{let t=100*s/e.globals.seriesTotals.reduce(((e,s)=>e+s),0);a.push(t)}return a}))}getCalculatedRatios(){let e=this.w.globals,s=[],t=0,a=0,i=0,r=0,l=[],o=.1,n=0;if(e.yRange=[],e.isMultipleYAxis)for(let s=0;s<e.minYArr.length;s++)e.yRange.push(Math.abs(e.minYArr[s]-e.maxYArr[s])),l.push(0);else e.yRange.push(Math.abs(e.minY-e.maxY));e.xRange=Math.abs(e.maxX-e.minX),e.zRange=Math.abs(e.maxZ-e.minZ);for(let t=0;t<e.yRange.length;t++)s.push(e.yRange[t]/e.gridHeight);if(a=e.xRange/e.gridWidth,t=e.yRange/e.gridWidth,i=e.xRange/e.gridHeight,r=e.zRange/e.gridHeight*16,r||(r=1),e.minY!==Number.MIN_VALUE&&0!==Math.abs(e.minY)&&(e.hasNegs=!0),e.isMultipleYAxis){l=[];for(let t=0;t<s.length;t++)l.push(-e.minYArr[t]/s[t])}else l.push(-e.minY/s[0]),e.minY!==Number.MIN_VALUE&&0!==Math.abs(e.minY)&&(o=-e.minY/t,n=e.minX/a);return{yRatio:s,invertedYRatio:t,zRatio:r,xRatio:a,invertedXRatio:i,baseLineInvertedY:o,baseLineY:l,baseLineX:n}}getLogSeries(e){const s=this.w;return s.globals.seriesLog=e.map(((e,t)=>s.config.yaxis[t]&&s.config.yaxis[t].logarithmic?e.map((e=>null===e?null:this.getLogVal(s.config.yaxis[t].logBase,e,t))):e)),s.globals.invalidLogScale?e:s.globals.seriesLog}getBaseLog(e,s){return Math.log(s)/Math.log(e)}getLogVal(e,s,t){if(0===s)return 0;const a=this.w,i=0===a.globals.minYArr[t]?-1:this.getBaseLog(e,a.globals.minYArr[t]),r=(0===a.globals.maxYArr[t]?0:this.getBaseLog(e,a.globals.maxYArr[t]))-i;if(s<1)return s/r;return(this.getBaseLog(e,s)-i)/r}getLogYRatios(e){const s=this.w,t=this.w.globals;return t.yLogRatio=e.slice(),t.logYRange=t.yRange.map(((e,a)=>{if(s.config.yaxis[a]&&this.w.config.yaxis[a].logarithmic){let e=-Number.MAX_VALUE,i=Number.MIN_VALUE,r=1;return t.seriesLog.forEach(((t,a)=>{t.forEach((t=>{s.config.yaxis[a]&&s.config.yaxis[a].logarithmic&&(e=Math.max(t,e),i=Math.min(t,i))}))})),r=Math.pow(t.yRange[a],Math.abs(i-e)/t.yRange[a]),t.yLogRatio[a]=r/t.gridHeight,r}})),t.invalidLogScale?e.slice():t.yLogRatio}static extendArrayProps(e,s,t){return s.yaxis&&(s=e.extendYAxis(s,t)),s.annotations&&(s.annotations.yaxis&&(s=e.extendYAxisAnnotations(s)),s.annotations.xaxis&&(s=e.extendXAxisAnnotations(s)),s.annotations.points&&(s=e.extendPointAnnotations(s))),s}}export default CoreUtils;
//# sourceMappingURL=/sm/e2d6fd4da0b2f0ba0e1d26f59c4c60c94fa6a0b0ba8785c09c8be816d6feb55b.map