/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/apexcharts@3.45.2/src/modules/Range.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Utils from"../utils/Utils";import DateTime from"../utils/DateTime";import Scales from"./Scales";class Range{constructor(e){this.ctx=e,this.w=e.w,this.scales=new Scales(e)}init(){this.setYRange(),this.setXRange(),this.setZRange()}getMinYMaxY(e,i=Number.MAX_VALUE,a=-Number.MAX_VALUE,t=null){const s=this.w.config,n=this.w.globals;let l=-Number.MAX_VALUE,r=Number.MIN_VALUE;null===t&&(t=e+1);const m=n.series;let x=m,o=m;"candlestick"===s.chart.type?(x=n.seriesCandleL,o=n.seriesCandleH):"boxPlot"===s.chart.type?(x=n.seriesCandleO,o=n.seriesCandleC):n.isRangeData&&(x=n.seriesRangeStart,o=n.seriesRangeEnd);for(let c=e;c<t;c++){n.dataPoints=Math.max(n.dataPoints,m[c].length),n.categoryLabels.length&&(n.dataPoints=n.categoryLabels.filter((e=>void 0!==e)).length),n.labels.length&&"datetime"!==s.xaxis.type&&0!==n.series.reduce(((e,i)=>e+i.length),0)&&(n.dataPoints=Math.max(n.dataPoints,n.labels.length));for(let e=0;e<n.series[c].length;e++){let t=m[c][e];null!==t&&Utils.isNumber(t)?(void 0!==o[c][e]&&(l=Math.max(l,o[c][e]),i=Math.min(i,o[c][e])),void 0!==x[c][e]&&(i=Math.min(i,x[c][e]),a=Math.max(a,x[c][e])),"candlestick"!==this.w.config.chart.type&&"boxPlot"!==this.w.config.chart.type&&"rangeArea"===this.w.config.chart.type&&"rangeBar"===this.w.config.chart.type||("candlestick"!==this.w.config.chart.type&&"boxPlot"!==this.w.config.chart.type||void 0!==n.seriesCandleC[c][e]&&(l=Math.max(l,n.seriesCandleO[c][e]),l=Math.max(l,n.seriesCandleH[c][e]),l=Math.max(l,n.seriesCandleL[c][e]),l=Math.max(l,n.seriesCandleC[c][e]),"boxPlot"===this.w.config.chart.type&&(l=Math.max(l,n.seriesCandleM[c][e]))),!s.series[c].type||"candlestick"===s.series[c].type&&"boxPlot"===s.series[c].type&&"rangeArea"===s.series[c].type&&"rangeBar"===s.series[c].type||(l=Math.max(l,n.series[c][e]),i=Math.min(i,n.series[c][e])),a=l),n.seriesGoals[c]&&n.seriesGoals[c][e]&&Array.isArray(n.seriesGoals[c][e])&&n.seriesGoals[c][e].forEach((e=>{r!==Number.MIN_VALUE&&(r=Math.min(r,e.value),i=r),l=Math.max(l,e.value),a=l})),Utils.isFloat(t)&&(t=Utils.noExponents(t),n.yValueDecimal=Math.max(n.yValueDecimal,t.toString().split(".")[1].length)),r>x[c][e]&&x[c][e]<0&&(r=x[c][e])):n.hasNullValues=!0}}return"rangeBar"===s.chart.type&&n.seriesRangeStart.length&&n.isBarHorizontal&&(r=i),"bar"===s.chart.type&&(r<0&&l<0&&(l=0),r===Number.MIN_VALUE&&(r=0)),{minY:r,maxY:l,lowestY:i,highestY:a}}setYRange(){let e=this.w.globals,i=this.w.config;e.maxY=-Number.MAX_VALUE,e.minY=Number.MIN_VALUE;let a=Number.MAX_VALUE;if(e.isMultipleYAxis)for(let i=0;i<e.series.length;i++){const t=this.getMinYMaxY(i,a,null,i+1);e.minYArr.push(t.minY),e.maxYArr.push(t.maxY),a=t.lowestY}const t=this.getMinYMaxY(0,a,null,e.series.length);if(e.minY=t.minY,e.maxY=t.maxY,a=t.lowestY,i.chart.stacked&&this._setStackedMinMax(),("line"===i.chart.type||"area"===i.chart.type||"candlestick"===i.chart.type||"boxPlot"===i.chart.type||"rangeBar"===i.chart.type&&!e.isBarHorizontal)&&e.minY===Number.MIN_VALUE&&a!==-Number.MAX_VALUE&&a!==e.maxY){let t=e.maxY-a;(a>=0&&a<=10||void 0!==i.yaxis[0].min||void 0!==i.yaxis[0].max)&&(t=0),e.minY=a-5*t/100,a>0&&e.minY<0&&(e.minY=0),e.maxY=e.maxY+5*t/100}if(i.yaxis.forEach(((i,a)=>{void 0!==i.max&&("number"==typeof i.max?e.maxYArr[a]=i.max:"function"==typeof i.max&&(e.maxYArr[a]=i.max(e.isMultipleYAxis?e.maxYArr[a]:e.maxY)),e.maxY=e.maxYArr[a]),void 0!==i.min&&("number"==typeof i.min?e.minYArr[a]=i.min:"function"==typeof i.min&&(e.minYArr[a]=i.min(e.isMultipleYAxis?e.minYArr[a]===Number.MIN_VALUE?0:e.minYArr[a]:e.minY)),e.minY=e.minYArr[a])})),e.isBarHorizontal){["min","max"].forEach((a=>{void 0!==i.xaxis[a]&&"number"==typeof i.xaxis[a]&&("min"===a?e.minY=i.xaxis[a]:e.maxY=i.xaxis[a])}))}return e.isMultipleYAxis?(this.scales.setMultipleYScales(),e.minY=a,e.yAxisScale.forEach(((i,a)=>{e.minYArr[a]=i.niceMin,e.maxYArr[a]=i.niceMax}))):(this.scales.setYScaleForIndex(0,e.minY,e.maxY),e.minY=e.yAxisScale[0].niceMin,e.maxY=e.yAxisScale[0].niceMax,e.minYArr[0]=e.yAxisScale[0].niceMin,e.maxYArr[0]=e.yAxisScale[0].niceMax),{minY:e.minY,maxY:e.maxY,minYArr:e.minYArr,maxYArr:e.maxYArr,yAxisScale:e.yAxisScale}}setXRange(){let e=this.w.globals,i=this.w.config;const a="numeric"===i.xaxis.type||"datetime"===i.xaxis.type||"category"===i.xaxis.type&&!e.noLabelsProvided||e.noLabelsProvided||e.isXNumeric;if(e.isXNumeric&&(()=>{for(let i=0;i<e.series.length;i++)if(e.labels[i])for(let a=0;a<e.labels[i].length;a++)null!==e.labels[i][a]&&Utils.isNumber(e.labels[i][a])&&(e.maxX=Math.max(e.maxX,e.labels[i][a]),e.initialMaxX=Math.max(e.maxX,e.labels[i][a]),e.minX=Math.min(e.minX,e.labels[i][a]),e.initialMinX=Math.min(e.minX,e.labels[i][a]))})(),e.noLabelsProvided&&0===i.xaxis.categories.length&&(e.maxX=e.labels[e.labels.length-1],e.initialMaxX=e.labels[e.labels.length-1],e.minX=1,e.initialMinX=1),e.isXNumeric||e.noLabelsProvided||e.dataFormatXNumeric){let t;if(void 0===i.xaxis.tickAmount?(t=Math.round(e.svgWidth/150),"numeric"===i.xaxis.type&&e.dataPoints<30&&(t=e.dataPoints-1),t>e.dataPoints&&0!==e.dataPoints&&(t=e.dataPoints-1)):"dataPoints"===i.xaxis.tickAmount?(e.series.length>1&&(t=e.series[e.maxValsInArrayIndex].length-1),e.isXNumeric&&(t=e.maxX-e.minX-1)):t=i.xaxis.tickAmount,e.xTickAmount=t,void 0!==i.xaxis.max&&"number"==typeof i.xaxis.max&&(e.maxX=i.xaxis.max),void 0!==i.xaxis.min&&"number"==typeof i.xaxis.min&&(e.minX=i.xaxis.min),void 0!==i.xaxis.range&&(e.minX=e.maxX-i.xaxis.range),e.minX!==Number.MAX_VALUE&&e.maxX!==-Number.MAX_VALUE)if(i.xaxis.convertedCatToNumeric&&!e.dataFormatXNumeric){let i=[];for(let a=e.minX-1;a<e.maxX;a++)i.push(a+1);e.xAxisScale={result:i,niceMin:i[0],niceMax:i[i.length-1]}}else e.xAxisScale=this.scales.setXScale(e.minX,e.maxX);else e.xAxisScale=this.scales.linearScale(0,t,t,0,i.xaxis.stepSize),e.noLabelsProvided&&e.labels.length>0&&(e.xAxisScale=this.scales.linearScale(1,e.labels.length,t-1,0,i.xaxis.stepSize),e.seriesX=e.labels.slice());a&&(e.labels=e.xAxisScale.result.slice())}return e.isBarHorizontal&&e.labels.length&&(e.xTickAmount=e.labels.length),this._handleSingleDataPoint(),this._getMinXDiff(),{minX:e.minX,maxX:e.maxX}}setZRange(){let e=this.w.globals;if(e.isDataXYZ)for(let i=0;i<e.series.length;i++)if(void 0!==e.seriesZ[i])for(let a=0;a<e.seriesZ[i].length;a++)null!==e.seriesZ[i][a]&&Utils.isNumber(e.seriesZ[i][a])&&(e.maxZ=Math.max(e.maxZ,e.seriesZ[i][a]),e.minZ=Math.min(e.minZ,e.seriesZ[i][a]))}_handleSingleDataPoint(){const e=this.w.globals,i=this.w.config;if(e.minX===e.maxX){let a=new DateTime(this.ctx);if("datetime"===i.xaxis.type){const t=a.getDate(e.minX);i.xaxis.labels.datetimeUTC?t.setUTCDate(t.getUTCDate()-2):t.setDate(t.getDate()-2),e.minX=new Date(t).getTime();const s=a.getDate(e.maxX);i.xaxis.labels.datetimeUTC?s.setUTCDate(s.getUTCDate()+2):s.setDate(s.getDate()+2),e.maxX=new Date(s).getTime()}else("numeric"===i.xaxis.type||"category"===i.xaxis.type&&!e.noLabelsProvided)&&(e.minX=e.minX-2,e.initialMinX=e.minX,e.maxX=e.maxX+2,e.initialMaxX=e.maxX)}}_getMinXDiff(){const e=this.w.globals;e.isXNumeric&&e.seriesX.forEach(((i,a)=>{1===i.length&&i.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length-1]);const t=i.slice();t.sort(((e,i)=>e-i)),t.forEach(((i,a)=>{if(a>0){let s=i-t[a-1];s>0&&(e.minXDiff=Math.min(s,e.minXDiff))}})),1!==e.dataPoints&&e.minXDiff!==Number.MAX_VALUE||(e.minXDiff=.5)}))}_setStackedMinMax(){const e=this.w.globals;if(!e.series.length)return;let i=e.seriesGroups;i.length||(i=[this.w.config.series.map((e=>e.name))]);let a={},t={};i.forEach((i=>{a[i]=[],t[i]=[];this.w.config.series.map(((e,a)=>i.indexOf(e.name)>-1?a:null)).filter((e=>null!==e)).forEach((s=>{for(let n=0;n<e.series[e.maxValsInArrayIndex].length;n++){void 0===a[i][n]&&(a[i][n]=0,t[i][n]=0),(this.w.config.chart.stacked&&!e.comboCharts||this.w.config.chart.stacked&&e.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===this.w.config.series?.[s]?.type))&&null!==e.series[s][n]&&Utils.isNumber(e.series[s][n])&&(e.series[s][n]>0?a[i][n]+=parseFloat(e.series[s][n])+1e-4:t[i][n]+=parseFloat(e.series[s][n]))}}))})),Object.entries(a).forEach((([i])=>{a[i].forEach(((s,n)=>{e.maxY=Math.max(e.maxY,a[i][n]),e.minY=Math.min(e.minY,t[i][n])}))}))}}export default Range;
//# sourceMappingURL=/sm/3d285853ee87aadc20c81167b322287c7f85c555f9e12be8b57fcf740f21b015.map