/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/apexcharts@3.45.2/src/modules/Scales.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Utils from"../utils/Utils";export default class Range{constructor(i){this.ctx=i,this.w=i.w}niceScale(i,a,e=5,t=0,l){const s=this.w;let o=Math.abs(a-i);if("dataPoints"===(e=this._adjustTicksForSmallRange(e,t,o))&&(e=s.globals.dataPoints-1),i===Number.MIN_VALUE&&0===a||!Utils.isNumber(i)&&!Utils.isNumber(a)||i===Number.MIN_VALUE&&a===-Number.MAX_VALUE){return i=0,a=e,this.linearScale(i,a,e,t,s.config.yaxis[t].stepSize)}i>a?(console.warn("axis.min cannot be greater than axis.max"),a=i+.1):i===a&&(i=0===i?0:i-.5,a=0===a?2:a+.5);let n=[];o<1&&l&&("candlestick"===s.config.chart.type||"candlestick"===s.config.series[t].type||"boxPlot"===s.config.chart.type||"boxPlot"===s.config.series[t].type||s.globals.isRangeData)&&(a*=1.01);let r=e+1;r<2?r=2:r>2&&(r-=2);let c=o/r,h=Math.floor(Utils.log10(c)),x=Math.pow(10,h),m=Math.round(c/x);m<1&&(m=1);let u=m*x;s.config.yaxis[t].stepSize&&(u=s.config.yaxis[t].stepSize),s.globals.isBarHorizontal&&s.config.xaxis.stepSize&&"datetime"!==s.config.xaxis.type&&(u=s.config.xaxis.stepSize);let f=u*Math.floor(i/u),g=u*Math.ceil(a/u),p=f;if(l&&o>2){for(;n.push(Utils.stripNumber(p,7)),p+=u,!(p>g););return{result:n,niceMin:n[0],niceMax:n[n.length-1]}}{n=[];let t=i;n.push(Utils.stripNumber(t,7));let l=Math.abs(a-i)/e;for(let i=0;i<=e;i++)t+=l,n.push(t);return n[n.length-2]>=a&&n.pop(),{result:n,niceMin:n[0],niceMax:n[n.length-1]}}}linearScale(i,a,e=5,t=0,l=void 0){let s=Math.abs(a-i);"dataPoints"===(e=this._adjustTicksForSmallRange(e,t,s))&&(e=this.w.globals.dataPoints-1),l||(l=s/e),e===Number.MAX_VALUE&&(e=5,l=1);let o=[],n=i;for(;e>=0;)o.push(n),n+=l,e-=1;return{result:o,niceMin:o[0],niceMax:o[o.length-1]}}logarithmicScaleNice(i,a,e){a<=0&&(a=Math.max(i,e)),i<=0&&(i=Math.min(a,e));const t=[],l=Math.ceil(Math.log(a)/Math.log(e)+1);for(let a=Math.floor(Math.log(i)/Math.log(e));a<l;a++)t.push(Math.pow(e,a));return{result:t,niceMin:t[0],niceMax:t[t.length-1]}}logarithmicScale(i,a,e){a<=0&&(a=Math.max(i,e)),i<=0&&(i=Math.min(a,e));const t=[],l=Math.log(a)/Math.log(e),s=Math.log(i)/Math.log(e),o=l-s,n=Math.round(o),r=o/n;for(let i=0,a=s;i<n;i++,a+=r)t.push(Math.pow(e,a));return t.push(Math.pow(e,l)),{result:t,niceMin:i,niceMax:a}}_adjustTicksForSmallRange(i,a,e){let t=i;if(void 0!==a&&this.w.config.yaxis[a].labels.formatter&&void 0===this.w.config.yaxis[a].tickAmount){const i=Number(this.w.config.yaxis[a].labels.formatter(1));Utils.isNumber(i)&&0===this.w.globals.yValueDecimal&&(t=Math.ceil(e))}return t<i?t:i}setYScaleForIndex(i,a,e){const t=this.w.globals,l=this.w.config;let s=t.isBarHorizontal?l.xaxis:l.yaxis[i];void 0===t.yAxisScale[i]&&(t.yAxisScale[i]=[]);let o=Math.abs(e-a);if(s.logarithmic&&o<=5&&(t.invalidLogScale=!0),s.logarithmic&&o>5)t.allSeriesCollapsed=!1,t.yAxisScale[i]=this.logarithmicScale(a,e,s.logBase),t.yAxisScale[i]=s.forceNiceScale?this.logarithmicScaleNice(a,e,s.logBase):this.logarithmicScale(a,e,s.logBase);else if(e!==-Number.MAX_VALUE&&Utils.isNumber(e))if(t.allSeriesCollapsed=!1,void 0===s.min&&void 0===s.max||s.forceNiceScale){const n=void 0===l.yaxis[i].max&&void 0===l.yaxis[i].min||l.yaxis[i].forceNiceScale;t.yAxisScale[i]=this.niceScale(a,e,s.tickAmount?s.tickAmount:o<5&&o>1?o+1:5,i,n)}else t.yAxisScale[i]=this.linearScale(a,e,s.tickAmount,i,l.yaxis[i].stepSize);else t.yAxisScale[i]=this.linearScale(0,5,5,i,l.yaxis[i].stepSize)}setXScale(i,a){const e=this.w,t=e.globals;let l=Math.abs(a-i);return a!==-Number.MAX_VALUE&&Utils.isNumber(a)?t.xAxisScale=this.linearScale(i,a,e.config.xaxis.tickAmount?e.config.xaxis.tickAmount:l<5&&l>1?l+1:5,0,e.config.xaxis.stepSize):t.xAxisScale=this.linearScale(0,5,5),t.xAxisScale}setMultipleYScales(){const i=this.w.globals,a=this.w.config,e=i.minYArr.concat([]),t=i.maxYArr.concat([]);let l=[];a.yaxis.forEach(((i,s)=>{let o=s;a.series.forEach(((a,e)=>{a.name===i.seriesName&&(o=e,s!==e?l.push({index:e,similarIndex:s,alreadyExists:!0}):l.push({index:e}))}));let n=e[o],r=t[o];this.setYScaleForIndex(s,n,r)})),this.sameScaleInMultipleAxes(e,t,l)}sameScaleInMultipleAxes(i,a,e){const t=this.w.config,l=this.w.globals;let s=[];e.forEach((i=>{i.alreadyExists&&(void 0===s[i.index]&&(s[i.index]=[]),s[i.index].push(i.index),s[i.index].push(i.similarIndex))})),l.yAxisSameScaleIndices=s,s.forEach(((i,a)=>{s.forEach(((e,t)=>{var l,o;a!==t&&(l=i,o=e,l.filter((i=>-1!==o.indexOf(i)))).length>0&&(s[a]=s[a].concat(s[t]))}))}));let o=s.map((i=>i.filter(((a,e)=>i.indexOf(a)===e)))).map((i=>i.sort()));s=s.filter((i=>!!i));let n=o.slice(),r=n.map((i=>JSON.stringify(i)));n=n.filter(((i,a)=>r.indexOf(JSON.stringify(i))===a));let c=[],h=[];i.forEach(((i,e)=>{n.forEach(((t,l)=>{t.indexOf(e)>-1&&(void 0===c[l]&&(c[l]=[],h[l]=[]),c[l].push({key:e,value:i}),h[l].push({key:e,value:a[e]}))}))}));let x=Array.apply(null,Array(n.length)).map(Number.prototype.valueOf,Number.MIN_VALUE),m=Array.apply(null,Array(n.length)).map(Number.prototype.valueOf,-Number.MAX_VALUE);c.forEach(((i,a)=>{i.forEach(((i,e)=>{x[a]=Math.min(i.value,x[a])}))})),h.forEach(((i,a)=>{i.forEach(((i,e)=>{m[a]=Math.max(i.value,m[a])}))})),i.forEach(((i,a)=>{h.forEach(((i,e)=>{let s=x[e],o=m[e];t.chart.stacked&&(o=0,i.forEach(((i,a)=>{i.value!==-Number.MAX_VALUE&&(o+=i.value),s!==Number.MIN_VALUE&&(s+=c[e][a].value)}))),i.forEach(((e,n)=>{i[n].key===a&&(void 0!==t.yaxis[a].min&&(s="function"==typeof t.yaxis[a].min?t.yaxis[a].min(l.minY):t.yaxis[a].min),void 0!==t.yaxis[a].max&&(o="function"==typeof t.yaxis[a].max?t.yaxis[a].max(l.maxY):t.yaxis[a].max),this.setYScaleForIndex(a,s,o))}))}))}))}autoScaleY(i,a,e){i||(i=this);const t=i.w;if(t.globals.isMultipleYAxis||t.globals.collapsedSeries.length)return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."),a;const l=t.globals.seriesX[0];let s=t.config.chart.stacked;return a.forEach(((i,o)=>{let n=0;for(let i=0;i<l.length;i++)if(l[i]>=e.xaxis.min){n=i;break}let r,c,h=t.globals.minYArr[o],x=t.globals.maxYArr[o],m=t.globals.stackedSeriesTotals;t.globals.series.forEach(((o,u)=>{let f=o[n];s?(f=m[n],r=c=f,m.forEach(((i,a)=>{l[a]<=e.xaxis.max&&l[a]>=e.xaxis.min&&(i>c&&null!==i&&(c=i),o[a]<r&&null!==o[a]&&(r=o[a]))}))):(r=c=f,o.forEach(((i,a)=>{if(l[a]<=e.xaxis.max&&l[a]>=e.xaxis.min){let e=i,l=i;t.globals.series.forEach(((t,s)=>{null!==i&&(e=Math.min(t[a],e),l=Math.max(t[a],l))})),l>c&&null!==l&&(c=l),e<r&&null!==e&&(r=e)}}))),void 0===r&&void 0===c&&(r=h,c=x),r*=r<0?1.1:.9,c*=c<0?.9:1.1,0===r&&0===c&&(r=-1,c=1),c<0&&c<x&&(c=x),r<0&&r>h&&(r=h),a.length>1?(a[u].min=void 0===i.min?r:i.min,a[u].max=void 0===i.max?c:i.max):(a[0].min=void 0===i.min?r:i.min,a[0].max=void 0===i.max?c:i.max)}))})),a}}
//# sourceMappingURL=/sm/6a9b59a168c68a5064981036c593f18697b4b110e24b0111a6c32107b04c7962.map